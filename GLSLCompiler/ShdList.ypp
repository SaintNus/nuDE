/*!
 * \file ShdList.ypp
 * \brief Shader list compiler.
 * \author Nus
 * \date 2011/12/25 21:24
 */

%{

#include "Settings.h"
#include "Utility.h"
#include "StringTable.h"
#include "ShaderList.h"

extern "C"
{

int yywrap(void);
int yylex(void);

void yyset_in(FILE* in_str);
FILE* yyget_in(void);
int yyget_lineno(void);

}

#if defined(DEBUG)
extern "C" void yyset_debug(int debug_flag);
extern int yydebug;
#endif
 
%}

%token PREPROCESSOR
%token PROGRAM
%token VERTEX_SHADER
%token VERTEX_PREPROCESSOR
%token FRAGMENT_SHADER
%token FRAGMENT_PREPROCESSOR

%token STRING

%token QUOTE
%token EQUAL

%token COLON
%token COMMA
%token SEMI_COLON

%token OPEN_BRACE
%token CLOSE_BRACE
%token OPEN_BRACKET
%token CLOSE_BRACKET

%%

start:
  // Empty.
  |
  start global_statement
  ;

global_statement:
  PROGRAM bracketed_name OPEN_BRACE statements CLOSE_BRACE
  {
    ShaderList::getProgramScratch()->setName(StringTable::getString($2)->lineNo(),
                                             StringTable::getString($2)->string());
    ShaderList::instance()->addProgram(ShaderList::getProgramScratch());
    ShaderList::setProgramScratch(nullptr);
  }
  |
  PREPROCESSOR COLON preprocessors SEMI_COLON
  {
    ShaderList::instance()->addGlobalPreproc(ShaderList::getPreprocScratch());
    ShaderList::setPreprocScratch(nullptr);
  }
  ;

preprocessors:
  // Empty.
  |
  preprocessors COMMA definition
  |
  preprocessors definition
  ;

definition:
  STRING EQUAL STRING
  {
    const char* def = StringTable::getString($1)->string();
    const char* value = StringTable::getString($3)->string();
    ShaderList::addPreprocScratch(new PreProcessor(StringTable::getString($1)->lineNo(),
                                                   def,
                                                   value));
  }
  |
  STRING
  {
    const char* def = StringTable::getString($1)->string();
    ShaderList::addPreprocScratch(new PreProcessor(StringTable::getString($1)->lineNo(),
                                                   def));
  }
  ;

quoted_name:
  QUOTE STRING QUOTE
  {
    $$ = $2;
  }
  ;

statements:
  |
  statements statement
  ;

statement:
  VERTEX_SHADER COLON quoted_name SEMI_COLON
  {
    Shader* p_shd = ShaderList::getProgramScratch()->createVertexShader();
    p_shd->setFileName(StringTable::getString($3)->lineNo(),
                       StringTable::getString($3)->string());
  }
  |
  FRAGMENT_SHADER COLON quoted_name SEMI_COLON
  {
    Shader* p_shd = ShaderList::getProgramScratch()->createFragmentShader();
    p_shd->setFileName(StringTable::getString($3)->lineNo(),
                       StringTable::getString($3)->string());
  }
  |
  PREPROCESSOR COLON preprocessors SEMI_COLON
  {
    ShaderList::getProgramScratch()->addPreproc(ShaderList::getPreprocScratch());
    ShaderList::setPreprocScratch(nullptr);
  }
  |
  VERTEX_PREPROCESSOR COLON preprocessors SEMI_COLON
  {
    Shader* p_shd = ShaderList::getProgramScratch()->createVertexShader();
    p_shd->addPreproc(ShaderList::getPreprocScratch());
    ShaderList::setPreprocScratch(nullptr);
  }
  |
  FRAGMENT_PREPROCESSOR COLON preprocessors SEMI_COLON
  {
    Shader* p_shd = ShaderList::getProgramScratch()->createFragmentShader();
    p_shd->addPreproc(ShaderList::getPreprocScratch());
    ShaderList::setPreprocScratch(nullptr);
  }
  ;

bracketed_name:
  OPEN_BRACKET STRING CLOSE_BRACKET
  {
    $$ = $2;
  }
  ;

%%

int yywrap(void)
{
  // Do not wrap...
  return 1;
} 
  
int main(int argc, const char** argv)
{
  Settings setting(argc, argv);

#if defined(DEBUG)
  yydebug = setting.isDebug() ? 1 : 0;
  yyset_debug(yydebug);
#endif

  if(setting.isVersion() || setting.isVerbose() || setting.isHelp())
    fprintf(stdout, "GLSL Property Compiler - %s\nVersion 1.0\n", _CONFIGURATION_);

  if(setting.isVersion())
    return ErrorAppStartup;

  if(setting.isHelp()) {
    fprintf(stdout, "Usage: glslpc [ --output-file=file_name ] [ --force-write ]\n");
    fprintf(stdout, "              [ --intermediate-dir=directory ] [ --verbose ]\n");
    fprintf(stdout, "              input_file\n");
    fprintf(stdout, "       glslpc --version\n");
    fprintf(stdout, "       glslpc --help\n");
    return ErrorAppStartup;
  }

  if(!setting.isValid()) {
    fprintf(stdout, "Invalid argument(s).\n");
    return ErrorAppStartup;
  }

  {
    FILE* file = fopen(setting.getInputName(), "rb");

    if(!file) {
      fprintf(stderr, "Critical error: cannot open \"%s\".\n", setting.getInputName());
      return ErrorIO;
    }

    yyset_in(file);
  }

  if(!setting.isForceWrite()) {
    int ret = ErrorNone;
    char buffer[PATH_MAX];
    FILE* file = nullptr;

    snprintf(buffer, PATH_MAX, "%s.h", setting.getOutputName());
    buffer[PATH_MAX - 1] = 0x00;
    file = fopen(buffer, "rb");
    if(file) {
      fprintf(stderr, "Critical error: File \"%s\" exists.\n", buffer);
      fclose(file);
      ret = ErrorIO;
    }

    snprintf(buffer, PATH_MAX, "%s.cpp", setting.getOutputName());
    buffer[PATH_MAX - 1] = 0x00;
    file = fopen(buffer, "rb");
    if(file) {
      fprintf(stderr, "Critical error: File \"%s\" exists.\n", buffer);
      fclose(file);
      ret = ErrorIO;
    }

    if(ret != ErrorNone) {
      fprintf(stderr, "Try using --force-write to rewrite existing file(s).\n");
      return ret;
    }
  }

  {
    int ret = ErrorNone;
    char buffer[PATH_MAX];
    FILE* file = nullptr;

    snprintf(buffer, PATH_MAX, "%s.h", setting.getOutputName());
    buffer[PATH_MAX - 1] = 0x00;

    if(MakePath(buffer)) {
      fprintf(stderr, "Critical error: Create path to \"%s\".\n", buffer);
      return ErrorFileSystem;
    }

    file = fopen(buffer, "w");
    if(file) {
      SetOutputHeader(file);
    } else {
      fprintf(stderr, "Critical error: Cannot write to \"%s\".\n", buffer);
      ret = ErrorIO;
    }

    snprintf(buffer, PATH_MAX, "%s.cpp", setting.getOutputName());
    buffer[PATH_MAX - 1] = 0x00;
    file = fopen(buffer, "w");
    if(file) {
      SetOutputSource(file);
    } else {
      fprintf(stderr, "Critical error: Cannot write to \"%s\".\n", buffer);
      ret = ErrorIO;
    }

    if(ret != ErrorNone) {
      if(OutputHeader()) {
        fclose(OutputHeader());
        SetOutputHeader(nullptr);
      }
      if(OutputSource()) {
        fclose(OutputSource());
        SetOutputSource(nullptr);
      }
      return ret;
    }
  }

  {
    char buffer[PATH_MAX];

    strncpy(buffer, setting.getIntermediateDir(), PATH_MAX);
    buffer[PATH_MAX - 1] = '\0';
    if(buffer[strlen(buffer) - 1] != '/') {
      size_t len = strlen(buffer) + 1;
      if(len < PATH_MAX) {
        buffer[len - 1] = '/';
        buffer[len] = '\0';
      } else {
        fprintf(stderr, "Critical error: Cannot create intermediate directory.\n");
        return ErrorFileSystem;
      }
    }

    if(MakePath(buffer)) {
      fprintf(stderr, "Critical error: Cannot create intermediate directory.\n");
      return ErrorFileSystem;
    }
  }

  ShaderList::createInstance();

  yyparse();

  fclose(yyget_in());
  yyset_in(nullptr);

  if(yyget_iserror()) {
    ShaderList::deleteInstance();
    return ErrorShdListParse;
  }

  if(setting.isVerbose())
    DumpList();

  int ret = BuildList(setting.getIntermediateDir());

  fclose(OutputHeader());
  SetOutputHeader(nullptr);
  fclose(OutputSource());
  SetOutputSource(nullptr);

  ShaderList::deleteInstance();

  return ret;
}
